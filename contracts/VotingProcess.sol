// SPDX-License-Identifier: AGPL-3.0-or-later

pragma solidity ^0.6.9;
pragma experimental ABIEncoderV2;

import "./math/SafeAdd.sol";

/*
Process Mode flags

The process mode defines how the process behaves externally. It affects both the Vochain, the contract itself and even the metadata.
0x00011111
     |||||
     ||||`- autoStart
     |||`-- interruptible
     ||`--- dynamicCensus
     |`---- allowVoteOverride
     `----- encryptedMetadata
*/

/*
Envelope Type flags

The envelope type tells how the vote envelope will be formatted and handled. Its value is generated by combining the flags below.
0x00000111
       |||
       ||`- serial
       |`-- anonymous
       `--- encryptedVote
*/

contract VotingProcess {
    // CONSTANTS AND ENUMS

    // Process Mode flags
    uint8 internal constant MODE_AUTO_START = 1 << 0;
    uint8 internal constant MODE_INTERRUPTIBLE = 1 << 1;
    uint8 internal constant MODE_DYNAMIC_CENSUS = 1 << 2;
    uint8 internal constant MODE_ALLOW_VOTE_OVERWRITE = 1 << 3;
    uint8 internal constant MODE_ENCRYPTED_METADATA = 1 << 4;

    // Envelope Type flags
    uint8 internal constant ENV_TYPE_SERIAL = 1 << 0;
    uint8 internal constant ENV_TYPE_ANONYMOUS = 1 << 1;
    uint8 internal constant ENV_TYPE_ENCRYPTED_VOTES = 1 << 2;

    // Process status
    enum Status {READY, ENDED, CANCELED, PAUSED, RESULTS}

    // LIBRARIES

    using SafeAdd for uint8;

    // GLOBAL DATA

    address internal contractOwner; // See `onlyContractOwner`

    struct Namespace {
        string chainId;
        string genesis; // Content Hashed URI
        string[] validators; // Public key array
        address[] oracles; // Oracles allowed to create Vochain processes and publish results on this contract/namespace
    }
    mapping(uint16 => Namespace) internal namespaces;

    // DATA STRUCTS

    struct Process {
        uint8 mode; // The selected process mode. See: https://vocdoni.io/docs/#/architecture/components/process
        uint8 envelopeType; // One of valid envelope types, see: https://vocdoni.io/docs/#/architecture/components/process
        address entityAddress; // The Ethereum address of the Entity
        uint64 startBlock; // Tendermint block number on which the voting process starts
        uint32 blockCount; // Amount of Tendermint blocks during which the voting process should be active
        string metadata; // Content Hashed URI of the JSON meta data (See Data Origins)
        string censusMerkleRoot; // Hex string with the Merkle Root hash of the census
        string censusMerkleTree; // Content Hashed URI of the exported Merkle Tree (not including the public keys)
        Status status; // One of 0 [ready], 1 [ended], 2 [canceled], 3 [paused], 4 [results]
        uint8 questionIndex; // The index of the currently active question (only assembly processes)
        // How many choices should be on every question.
        // questionCount >= 1
        uint8 questionCount;
        // Determines the acceptable value range.
        // N => valid votes will range from 1 to N (inclusive)
        uint8 maxVoteOverwrites; // How many times a vote can be replaced (only the last counts)
        uint8 maxValue;
        // Choices for a question cannot appear twice or more
        bool uniqueValues;
        // Limits up to how much cost, the values of a vote can add up to (if applicable).
        // 0 => No limit / Not applicable
        uint16 maxTotalCost;
        // Defines the exponent that will be used to compute the "cost" of the options voted and compare it against `maxTotalCost`.
        // totalCost = Î£ (value[i] ** costExponent) <= maxTotalCost
        //
        // Exponent range:
        // - 0 => 0.0000
        // - 65535 => 6.5535
        uint16 costExponent;
        uint16 namespace; // See namespaces above
        bytes32 paramsSignature; // entity.sign({...}) // fields that the oracle uses to authentify process creation
        // Self-assign to a certain namespace.
        // This will determine the oracles that listen and react to it.
        // Indirectly, it will also determine the Vochain that hosts this process.
        string results; // string containing the results
    }

    // PER-PROCESS DATA

    Process[] internal processes; // Array of processes. Index [0] is reserved (see setResults)
    mapping(bytes32 => uint256) internal processesIndex; // Mapping between processId's and their index within `processes[]`
    mapping(address => uint256) internal entityProcessCount; // Index of the last process for each entity address

    // EVENTS

    event NamespaceUpdated(uint16 namespace);
    event ChainIdUpdated(string chainId, uint16 namespace);
    event GenesisUpdated(string genesis, uint16 namespace);
    event ValidatorAdded(string validatorPublicKey, uint16 namespace);
    event ValidatorRemoved(string validatorPublicKey, uint16 namespace);
    event OracleAdded(address oracleAddress, uint16 namespace);
    event OracleRemoved(address oracleAddress, uint16 namespace);

    event ProcessCreated(
        bytes32 processId,
        uint16 namespace,
        string merkleTree
    );
    event StatusUpdated(bytes32 processId, uint16 namespace, Status status);
    event QuestionIndexUpdated(
        bytes32 processId,
        uint16 namespace,
        uint8 newIndex
    );
    event CensusUpdated(bytes32 processId, uint16 namespace);
    event ResultsAvailable(bytes32 processId);

    // MODIFIERS

    modifier onlyEntity(bytes32 processId) {
        uint256 processIdx = getProcessIndex(processId);
        require(
            processes[processIdx].entityAddress == msg.sender,
            "Invalid entity"
        );
        _;
    }

    modifier onlyContractOwner {
        require(msg.sender == contractOwner, "onlyContractOwner");
        _;
    }

    // HELPERS

    function getEntityProcessCount(address entityAddress)
        public
        view
        returns (uint256)
    {
        return entityProcessCount[entityAddress];
    }

    // Get the next process ID to use for an entity
    function getNextProcessId(address entityAddress, uint16 namespace)
        public
        view
        returns (bytes32)
    {
        uint256 processCountIndex = getEntityProcessCount(entityAddress);
        return getProcessId(entityAddress, processCountIndex, namespace);
    }

    // Compute a process ID
    function getProcessId(
        address entityAddress,
        uint256 processCountIndex,
        uint16 namespace
    ) public pure returns (bytes32) {
        return
            keccak256(
                abi.encodePacked(entityAddress, processCountIndex, namespace)
            );
    }

    function getProcessIndex(bytes32 processId) public view returns (uint256) {
        return processesIndex[processId];
    }

    function equalStrings(string memory str1, string memory str2)
        private
        pure
        returns (bool)
    {
        return
            keccak256(abi.encodePacked((str1))) ==
            keccak256(abi.encodePacked((str2)));
    }

    // GLOBAL METHODS

    constructor() public {
        contractOwner = msg.sender;

        // Fill an empty process at index 0.
        // NOTE: This way, real processes will always have a positive index on processesIndex.

        Process memory process = Process({
            mode: 0,
            envelopeType: 0,
            entityAddress: address(0x0),
            startBlock: 0,
            blockCount: 0,
            metadata: "",
            censusMerkleRoot: "",
            censusMerkleTree: "",
            status: Status.CANCELED,
            questionIndex: 0,
            questionCount: 0,
            maxVoteOverwrites: 0,
            maxValue: 0,
            uniqueValues: false,
            maxTotalCost: 0,
            costExponent: 0,
            namespace: 0,
            paramsSignature: 0,
            results: ""
        });
        processes.push(process); // Fill the [0] index
    }

    function setNamespace(
        uint16 namespace,
        string memory chainId,
        string memory genesis,
        string[] memory validators,
        address[] memory oracles
    ) public onlyContractOwner {
        namespaces[namespace] = Namespace({
            chainId: chainId,
            genesis: genesis,
            validators: validators,
            oracles: oracles
        });
        emit NamespaceUpdated(namespace);
    }

    function setChainId(uint16 namespace, string memory newChainId)
        public
        onlyContractOwner
    {
        require(
            !equalStrings(namespaces[namespace].chainId, newChainId),
            "Must differ"
        );
        namespaces[namespace].chainId = newChainId;
        emit ChainIdUpdated(newChainId, namespace);
    }

    function setGenesis(uint16 namespace, string memory newGenesis)
        public
        onlyContractOwner
    {
        require(
            !equalStrings(namespaces[namespace].genesis, newGenesis),
            "Must differ"
        );

        namespaces[namespace].genesis = newGenesis;

        emit GenesisUpdated(newGenesis, namespace);
    }

    function addValidator(uint16 namespace, string memory validatorPublicKey)
        public
        onlyContractOwner
    {
        require(!isValidator(namespace, validatorPublicKey), "Already present");

        namespaces[namespace].validators.push(validatorPublicKey);

        emit ValidatorAdded(validatorPublicKey, namespace);
    }

    function removeValidator(
        uint16 namespace,
        uint256 idx,
        string memory validatorPublicKey
    ) public onlyContractOwner {
        uint256 currentLength = namespaces[namespace].validators.length;
        require(idx < currentLength, "Invalid index");
        require( // using `idx` to avoid searching/looping and using `validatorPublicKey` to enforce that the correct value is removed
            equalStrings(
                namespaces[namespace].validators[idx],
                validatorPublicKey
            ),
            "Index-key mismatch"
        );
        // swap with the last element from the list
        namespaces[namespace].validators[idx] = namespaces[namespace]
            .validators[currentLength - 1];
        namespaces[namespace].validators.pop();

        emit ValidatorRemoved(validatorPublicKey, namespace);
    }

    function addOracle(uint16 namespace, address oracleAddress)
        public
        onlyContractOwner
    {
        require(!isOracle(namespace, oracleAddress), "Already present");

        namespaces[namespace].oracles.push(oracleAddress);

        emit OracleAdded(oracleAddress, namespace);
    }

    function removeOracle(
        uint16 namespace,
        uint256 idx,
        address oracleAddress
    ) public onlyContractOwner {
        uint256 currentLength = namespaces[namespace].oracles.length;
        require(idx < currentLength, "Invalid index");
        require( // using `idx` to avoid searching/looping and using `oracleAddress` to enforce that the correct value is removed
            namespaces[namespace].oracles[idx] == oracleAddress,
            "Index-key mismatch"
        );

        // swap with the last element from the list
        namespaces[namespace].oracles[idx] = namespaces[namespace]
            .oracles[currentLength - 1];
        namespaces[namespace].oracles.pop();

        emit OracleRemoved(oracleAddress, namespace);
    }

    // GETTERS

    function getNamespace(uint16 namespace)
        public
        view
        returns (
            string memory chainId,
            string memory genesis,
            string[] memory validators,
            address[] memory oracles
        )
    {
        return (
            namespaces[namespace].chainId,
            namespaces[namespace].genesis,
            namespaces[namespace].validators,
            namespaces[namespace].oracles
        );
    }

    function isValidator(uint16 namespace, string memory validatorPublicKey)
        public
        view
        returns (bool)
    {
        for (uint256 i = 0; i < namespaces[namespace].validators.length; i++) {
            if (
                equalStrings(
                    namespaces[namespace].validators[i],
                    validatorPublicKey
                )
            ) {
                return true;
            }
        }
        return false;
    }

    function isOracle(uint16 namespace, address oracleAddress)
        public
        view
        returns (bool)
    {
        for (uint256 i = 0; i < namespaces[namespace].oracles.length; i++) {
            if (namespaces[namespace].oracles[i] == oracleAddress) {
                return true;
            }
        }
        return false;
    }

    function get(bytes32 processId)
        public
        view
        returns (
            uint8[2] memory, // [mode, envelopeType]
            address, // entityAddress
            string[3] memory, // [metadata, censusMerkleRoot, censusMerkleTree]
            uint64, // startBlock
            uint32, // blockCount
            Status, // status
            uint8[4] memory, // [questionIndex, questionCount, maxVoteOverwrites, maxValue]
            bool, // uniqueValues
            uint16[2] memory, // [maxTotalCost, costExponent]
            uint16, // namespace
            bytes32 // paramsSignature
        )
    {
        uint256 processIndex = getProcessIndex(processId);
        require(processIndex > 0, "Not found");

        return (
            [
                processes[processIndex].mode,
                processes[processIndex].envelopeType
            ],
            processes[processIndex].entityAddress,
            [
                processes[processIndex].metadata,
                processes[processIndex].censusMerkleRoot,
                processes[processIndex].censusMerkleTree
            ],
            processes[processIndex].startBlock,
            processes[processIndex].blockCount,
            processes[processIndex].status,
            [
                processes[processIndex].questionIndex,
                processes[processIndex].questionCount,
                processes[processIndex].maxVoteOverwrites,
                processes[processIndex].maxValue
            ],
            processes[processIndex].uniqueValues,
            [
                processes[processIndex].maxTotalCost,
                processes[processIndex].costExponent
            ],
            processes[processIndex].namespace,
            processes[processIndex].paramsSignature
        );
    }

    function getResults(bytes32 processId)
        public
        view
        returns (string memory results)
    {
        uint256 processIndex = getProcessIndex(processId);
        require(processIndex > 0, "Not found");

        results = processes[processIndex].results;
    }

    // ENTITY METHODS

    function create(
        uint8[2] memory mode_envelopeType, // [mode, envelopeType]
        string[3] memory metadata_merkleRoot_merkleTree, //  [metadata, merkleRoot, merkleTree]
        uint64 startBlock,
        uint32 blockCount,
        uint8[3] memory questionCount_maxVoteOverwrites_maxValue, // [questionCount, maxVoteOverwrites, maxValue]
        bool uniqueValues,
        uint16[2] memory maxTotalCost_costExponent, // [maxTotalCost, costExponent]
        uint16 namespace,
        bytes32 paramsSignature
    ) public {
        uint8 mode = mode_envelopeType[0];
        if (mode & MODE_AUTO_START != 0) {
            require(startBlock > 0, "Auto start requires a start block");
        }
        if (mode & MODE_INTERRUPTIBLE == 0) {
            require(blockCount > 0, "Uninterruptible needs blockCount");
        }
        require(
            bytes(metadata_merkleRoot_merkleTree[0]).length > 0,
            "No metadata"
        );
        require(
            bytes(metadata_merkleRoot_merkleTree[1]).length > 0,
            "No merkleRoot"
        );
        require(
            bytes(metadata_merkleRoot_merkleTree[2]).length > 0,
            "No merkleTree"
        );
        require(
            questionCount_maxVoteOverwrites_maxValue[0] > 0,
            "No questionCount"
        );
        if (mode & MODE_ALLOW_VOTE_OVERWRITE != 0) {
            require(
                questionCount_maxVoteOverwrites_maxValue[1] > 0,
                "Allow overwrite needs maxVoteOverwrites > 0"
            );
        }
        require(questionCount_maxVoteOverwrites_maxValue[2] > 0, "No maxValue");

        bytes32 processId = getNextProcessId(msg.sender, namespace);

        // By default, processes start PAUSED (auto start disabled)
        Status status = Status.PAUSED;

        if (mode & MODE_AUTO_START != 0) {
            // Auto-start enabled processes start in READY state
            status = Status.READY;
        }

        Process memory process = Process({
            mode: mode,
            envelopeType: mode_envelopeType[1],
            entityAddress: msg.sender,
            startBlock: startBlock,
            blockCount: blockCount,
            metadata: metadata_merkleRoot_merkleTree[0],
            censusMerkleRoot: metadata_merkleRoot_merkleTree[1],
            censusMerkleTree: metadata_merkleRoot_merkleTree[2],
            status: status,
            questionIndex: 0,
            questionCount: questionCount_maxVoteOverwrites_maxValue[0],
            maxVoteOverwrites: questionCount_maxVoteOverwrites_maxValue[1],
            maxValue: questionCount_maxVoteOverwrites_maxValue[2],
            uniqueValues: uniqueValues,
            maxTotalCost: maxTotalCost_costExponent[0],
            costExponent: maxTotalCost_costExponent[1],
            namespace: namespace,
            paramsSignature: paramsSignature,
            results: ""
        });

        processesIndex[processId] = processes.length; // N - 1 after the entry is pushed to the processes list
        processes.push(process);
        entityProcessCount[msg.sender]++;

        emit ProcessCreated(
            processId,
            namespace,
            metadata_merkleRoot_merkleTree[2]
        );
    }

    function setStatus(bytes32 processId, Status newStatus)
        public
        onlyEntity(processId)
    {
        require(
            uint8(newStatus) <= uint8(Status.PAUSED), // [READY 0..3 PAUSED] => RESULTS (4) is not allowed
            "Invalid status code"
        );

        uint256 processIndex = getProcessIndex(processId);

        // processId is guaranteed to exist (> 0) since onlyEntity(processId) enforces that
        // such process has been created by msg.sender

        Status currentStatus = processes[processIndex].status;
        if (currentStatus != Status.READY && currentStatus != Status.PAUSED) {
            // When currentStatus is [ENDED, CANCELED, RESULTS], no update is allowed
            revert("Process terminated");
        } else if (currentStatus == Status.PAUSED) {
            // newStatus can only be [READY, ENDED, CANCELED, PAUSED] (see the require above)

            if (processes[processIndex].mode & MODE_INTERRUPTIBLE == 0) {
                // Is not interruptible, we can only go from PAUSED to READY, the first time
                require(newStatus == Status.READY, "Not interruptible");
            }
        } else {
            // currentStatus is READY

            if (processes[processIndex].mode & MODE_INTERRUPTIBLE == 0) {
                // If not interruptible, no status update is allowed
                revert("Not interruptible");
            }

            // newStatus can only be [READY, ENDED, CANCELED, PAUSED] (see require above).
        }

        // If currentStatus is READY => Can go to [ENDED, CANCELED, PAUSED].
        // If currentStatus is PAUSED => Can go to [READY, ENDED, CANCELED].
        require(newStatus != currentStatus, "Must differ");

        // Note: the process can also be ended from incrementQuestionIndex
        // If questionIndex is already at the last one
        processes[processIndex].status = newStatus;

        emit StatusUpdated(
            processId,
            processes[processIndex].namespace,
            newStatus
        );
    }

    function incrementQuestionIndex(bytes32 processId)
        public
        onlyEntity(processId)
    {
        uint256 processIndex = getProcessIndex(processId);

        // processId is guaranteed to exist (> 0) since onlyEntity(processId) enforces that
        // such process has been created by msg.sender

        require(
            processes[processIndex].status == Status.READY,
            "Process not ready"
        );
        require( // If all votes should be sent within a single envelope, abort
            processes[processIndex].envelopeType & ENV_TYPE_SERIAL != 0,
            "Process not serial"
        );

        uint8 nextIdx = processes[processIndex].questionIndex.add8(1);

        if (nextIdx < processes[processIndex].questionCount) {
            processes[processIndex].questionIndex = nextIdx;

            // Not at the last question yet
            emit QuestionIndexUpdated(
                processId,
                processes[processIndex].namespace,
                nextIdx
            );
        } else {
            // The last question was currently active => End the process
            processes[processIndex].status = Status.ENDED;

            emit StatusUpdated(
                processId,
                processes[processIndex].namespace,
                Status.ENDED
            );
        }
    }

    function setCensus(
        bytes32 processId,
        string memory censusMerkleRoot,
        string memory censusMerkleTree
    ) public onlyEntity(processId) {
        require(bytes(censusMerkleRoot).length > 0, "No Merkle Root");
        require(bytes(censusMerkleTree).length > 0, "No Merkle Tree");

        uint256 processIndex = getProcessIndex(processId);

        // processId is guaranteed to exist (> 0) since onlyEntity(processId) enforces that
        // such process has been created by msg.sender

        require(
            processes[processIndex].status == Status.READY ||
                processes[processIndex].status == Status.PAUSED,
            "Process terminated"
        );
        require(
            processes[processIndex].mode & MODE_DYNAMIC_CENSUS != 0,
            "Read-only census"
        );

        processes[processIndex].censusMerkleRoot = censusMerkleRoot;
        processes[processIndex].censusMerkleTree = censusMerkleTree;

        emit CensusUpdated(processId, processes[processIndex].namespace);
    }

    function setResults(bytes32 processId, string memory results) public {
        require(bytes(results).length > 0, "No results");

        uint256 processIndex = getProcessIndex(processId);
        // The process must be created
        require(processIndex > 0, "Not found");

        // Only an Oracle within the process' namespace can set any results
        require(
            isOracle(processes[processIndex].namespace, msg.sender),
            "Not oracle"
        );
        require(
            processes[processIndex].entityAddress != address(0x0),
            "No process"
        );
        // cannot publish results on a canceled process or on a process
        // that already has results
        require(
            processes[processIndex].status != Status.CANCELED &&
                processes[processIndex].status != Status.RESULTS,
            "Canceled or already set"
        );

        processes[processIndex].results = results;
        processes[processIndex].status = Status.RESULTS;

        emit ResultsAvailable(processId);
    }
}
